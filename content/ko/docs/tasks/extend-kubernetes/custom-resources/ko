# CustomResourceDefinitions의 버전
crd에서 안정성 있는 API 레벨을 가르키는 것 또는 새로운 버전의 API로 업그레이드 하는 것과 현재 API 버전 사이의 변환을 하기 위해서 
이 페이지는 버전관리 정보를 crd에 추가하는 방법에 대해 설명 한다.

## 시작하기 전에
쿠버네티스 클러스터가 필요하다. 그리고 반드시 kubect cli 도구가 쿠버네티스 클러스터와 통신할 수 있도록 설정되어 있어야 한다.
이 튜토리얼을 진행할 때, 컨트롤 플레인 호스트 역할을 하지 않는 노드가 적어도 2개 이상 있는 클러스터로 진행하는 것을 추천한다.
클러스터가 준비되어있지 않다면, minikube를 이용하거나 아래의 쿠버네티스 플레이그라운드 중 하나를 사용해서 클러스터를 만들 수 있다.

	Killercoda
	Play with kubernetes

CustomResourceDefinition에 대한 기초적인 지식이 있어야 한다.
쿠버네티스 서버가 v1.16 혹은 그보다 더 최신 버전이어야 한다. 버전을 확인하기 위해서는 "kubectl version" 를 입력해서 확인할 수 있다.

## 둘러보기
CustomResourceDefinition API는 새로운 버전의 CRD의 소개와 업그레이드하기 위한 워크플로우를 제공한다.
CRD가 생성되었을 때, 최초의 버전이 "spec.verions" 목록에 적절한 안정성 수준과 버전의 번호로 설정 된다. 예를들어 v1beta 버전은 아직 안정적이지 않다라는 것을 의미한다. 모든 커스텀 리소스 오브젝트들은 이 버전에 저장이 된다.
CustomResourceDefinition이 생성되면, 클라이언트는 v1beta1 API를 사용하기 시작한다.
후에, "v1" 이라는 새로운 버전을 추가할 필요가 있을 수 있다.
새로운 버전 추가하기:
1. 변환 전략(conversion strategy)을 선택한다. custom resource 오브젝트들은 양쪽 버전 모두에서 제공되어야할 필요가 있다. 즉, 하나의 저장소를 사용하면서 서로 다른 버전으로 제공되어야할 필요가 종종 있다. 이것을 가능하게 하기 위해서는 반드시 custom resource 오브젝트들이
저장된 버전과 제공되어야할 버전으로 변환될 수 있어야 한다. 만약 스키마(schema)의 변경과 커스텀(custom) 로직이 요구되는 변환은 변환 웹훅(webhook)을 사용해야 한다. 스키마(schema)의 변경과 커스텀(custom) 로직이 없는 경우에 변환 전략을 기본 값인 "None" 으로 사용하면 된다.
그리고 다른 버전을 제공할 때 "apiVersion" 필드만 변경될 것이다.
2. 변환 웹훅을 사용한다면, 변환 웹훅을 생성하고 배포해야 한다. 자세한 내용은 "Webhook conversion"을 참고한다.
3. 새로운 버전을 추가하기 위해서 CustomResourceDefinition의 "spec.versions" 를 업데이트 한다. 그리고 "served: true"로 설정한다.
  "spec.conversion" 는 변환전략을 선책하기 위한 항목이다. 변환 웹훅을 사용한다면 웹훅을 호출하기 위해 "spec.conversion.webhookClientConfig" 를 설정한다.

새로운 버전이 추가되면 클라이언트는 점진적으로 새로운 버전으로 변경할 것이다. 일부 클라이언트는 이전 버전을 사용하는 반면에 또 다른 클라이언트는 새로운 버전을 사용하더라도 완벽하게 안전하다.

저장된 오브젝트를 새로운 버전으로 변경하기:
1. "upgrade existing objects to a new stored version" 섹션은 참고한다.
새로 저장된 버전으로 업그레이드 하는동안 그리도 그 이후에도 클라이언트가 이전 버전과 새로운 버전 둘다 사용하는 것은 안전하다.

이전 버전 삭제:
1. 모든 클라이언트가 새로운 버전으로 변경되었는지 확인한다. "kube-apiserver"의 로그를 보면 클라이언트가 이전 버전의 API를 접근하고 있는지 확인하는데 도움이 된다.
2. "spec.versions" 리스트에서 이전 버전의 "served" 항목값을 "false" 로 설정한다. 클라이언트가 예상치 못하게 이전 버전을 계속 사용하고 있다면, 이전 버전의 custom resource 오브젝트를 접근하려고 할 때 에러를 발생시킬 것이다. 에러가 발생한다면 이전 버전의 "served" 항목값을 다시 "true" 로 변경하고 클라이언트의 API 버전을 새로운 버전으로 변경한 다음 이 단계를 처음부터 다시 시작한다.
3. "upgrade of existing objects to the new stored version" 단계를 완료했는지 확인한다.
  1. CustomResourceDefinition의 "spec.versions" 목록에서 새로운 버전의 storage 가 true로 변경되었는지 확인한다.
  2. CustomResourceDefinition의 "status.storedVersions" 항목에서 이전 버전이 더이상 존재하지 않는지 확인한다.
4. CustomResourceDefinition의 "spec.versions" 리스트에서 이전 버전을 삭제한다.
5. 변환 웹훅에서 이전 버전에 대한 변환 지원을 삭제한다.

## Specify multiple versions 다양한 버전을 구체화한다.
CustomResourceDefinition API "versions" 항목은 당신이 개발한 여러가지 버전의 custom resource들을 지원하도록 사용할 수 있다. 버전들은 서로 다른 스키마를 가질 수 있으며, 변환 웹훅은  custom resource 버전 간의 변환을 할 수 있다.
변환 웹훅은 "Kubernetes API conventions"을 따라야 한다. 특히, "API change documentation" 문서의 유용한 gotchas 와 제안들을 보는 것이 좋다.

참고: "apiextensions.k8s.io/v1beta1" 에서  "versions" 항목 대신에 "version" 항목이 있다. "version" 항목은 deprecated 되었고, 선택사항이지만 이 항목이 빈 값이 아니라면 "versions" 의 첫번쨰 항목과 일치해야 한다.

이 예제는 두 종류의 버전을 가진 CustomResourceDefinition를 보여준다. 첫번째 예제는 모든 버전들이 같은 스키마를 사용하고 서로 간의 변환이 없다고 가정한다. YAML의 주석이 문맥을 제공해준다.


###	Version priority
###	Version deprecation
###	Version removal

## Webhook conversion
###	Write a conversion webhook server
### Deploy the conversion webhook service
###	Configure CustomResourceDefinition to use conversion webhooks
###	Contacting the webhook
###	URL
###	Service Reference

## Webhook request and response
###	Request
###	Response

## Writing, reading, and updating versioned CustomResourceDefinition objects
###	Previous storage versions

## Upgrade existing objects to a new stored version